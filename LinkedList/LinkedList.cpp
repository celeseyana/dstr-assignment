//#include "LinkedList.hpp"
//#include <iostream>
//#include <fstream>
//#include <string>
//#include <sstream>
//#include <algorithm>
//#include <iomanip>
//using namespace std;
//
//// WORKED
//// load positive and negative words into linked list
//void LinkedList::loadWords(const string& filename, WordNode*& head)
//{
//	string word;
//
//	ifstream file(filename);
//	if (!file.is_open())
//	{
//		cerr << "Error: Could not open file - " << filename << endl;
//		return;
//	}
//
//	WordNode* current = nullptr;
//
//	while (file >> word)
//	{
//		// Create a new WordNode
//		WordNode* newNode = new WordNode{ word, 0, nullptr };
//
//		if (head == nullptr)
//		{
//			head = newNode;
//		}
//		else
//		{
//			current->next = newNode;
//		}
//
//		current = newNode;
//	}
//
//	file.close();
//}
//
//// WORKED
//// insert word into linked list
//void LinkedList::insertIntoLinkedList(WordNode*& head, const string& word)
//{
//	WordNode* temp = head;
//	while (temp != nullptr)
//	{
//		if (temp->word == word)
//		{
//			temp->count++;
//			//cout << "Added / Updated word: " << word << " with count: " << temp->count << endl;
//			return;
//		}
//		temp = temp->next;
//	}
//	WordNode* newNode = new WordNode{ word, 1, head };
//	head = newNode;
//
//
//}
//
//// WORKED
//// count positive and negative words in review
//int LinkedList::countWordsInReview(const string& review, WordNode*& reviewNode, WordNode*& wordListHead)
//{
//	int count = 0;
//	stringstream ss(review);
//	string word;
//
//	while (ss >> word) {
//		// remove punctuation
//		// word.erase(remove_if(word.begin(), word.end(), ::ispunct), word.end());
//
//		for (WordNode* node = wordListHead; node != nullptr; node = node->next) {
//			if (word == node->word) {
//				count++;
//				insertIntoLinkedList(reviewNode, word);
//				insertIntoLinkedList(wordListHead, word);
//				break;
//			}
//		}
//	}
//	return count;
//}
//
//// WORKED
//// display words in the linked list
//void LinkedList::displayWordList(const string& label, WordNode* head)
//{
//	cout << label << ":" << endl;
//	for (WordNode* node = head; node != nullptr; node = node->next)
//	{
//		cout << " - " << node->word << " (" << node->count << " times)" << endl;
//	}
//}
//
//// WORKED
//// convert user rating from string to integer
//int LinkedList::convertStringRating(string ratingStr)
//{
//	try
//	{
//		return stoi(ratingStr);
//	}
//	catch (invalid_argument& e)
//	{
//		cerr << "Invalid rating format: " << ratingStr << endl;
//		return -1;
//	}
//	catch (out_of_range& e)
//	{
//		cerr << "Rating out of range: " << ratingStr << endl;
//		return -1;
//	}
//}
//
//// WORKED
//// calculate the sentiment score of the review
//// based on number of +ve and -ve words
//double LinkedList::calculateSentimentScore(int positiveCount, int negativeCount)
//{
//	int rawScore = positiveCount - negativeCount;
//	int maxScore = positiveCount + negativeCount;
//	int minScore = -(maxScore);
//
//	double normalizedScore = (rawScore - minScore) / double(maxScore - minScore);
//
//	return 1 + (4 * normalizedScore);
//}
//
//// WORKED
//// determine the level of sentiment based on its score
//string LinkedList::levelOfSentiment(double sentimentScore)
//{
//	switch (int(round(sentimentScore)))
//	{
//	case 1:	case 2:
//		return "Negative";
//	case 3:
//		return "Neutral";
//	case 4: case 5:
//		return "Positive";
//	default:
//		return "Unknown";
//	}
//}
//
//// WORKED
//// compare rating given by user with sentiment calculation
//void LinkedList::compareRatings(int userRating, double sentimentScore)
//{
//	cout << "Sentiment Score (1 - 5) = " << round(sentimentScore) << endl;
//	cout << "Rating given by user = " << userRating << endl;
//
//	if (round(sentimentScore) == userRating)
//	{
//		cout << "User's subjective evaluation MATCHES the sentiment score provided by the analysis. There is a consistency between the sentiment score generated by the analysis and the user's evaluation of the sentiment." << endl;
//	}
//	else
//	{
//		cout << "User's subjective evaluation DOES NOT MATCHES the sentiment score provided by the analysis. There is an inconsistency between the sentiment score generated by the analysis and the user's evaluation of the sentiment." << endl;
//	}
//}
//
//// WORKED
//// merge both +ve and -ve linked list
//WordNode* LinkedList::mergeLists(WordNode* positiveHead, WordNode* negativeHead)
//{
//	WordNode* combineHead = nullptr;
//	WordNode** tail = &combineHead;
//
//	// combine all nodes from the +ve linked list
//	while (positiveHead != nullptr)
//	{
//		*tail = new WordNode{ positiveHead->word, positiveHead->count, nullptr };
//		tail = &((*tail)->next);
//		positiveHead = positiveHead->next;
//	}
//
//	// combine all nodes from the -ve linked list
//	while (negativeHead != nullptr)
//	{
//		*tail = new WordNode{ negativeHead->word, negativeHead->count, nullptr };
//		tail = &((*tail)->next);
//		negativeHead = negativeHead->next;
//	}
//
//	return combineHead;
//}
//
//// selection sort function to sort the combined linked list
//// according to the word counts in ascending order
//void LinkedList::selectionSort(WordNode*& head)
//{
//	for (WordNode* i = head; i != nullptr; i = i->next)
//	{
//		WordNode* minNode = i;
//		for (WordNode* j = i->next; j != nullptr; j = j->next)
//		{
//			if (j->count < minNode->count)
//			{
//				minNode = j;
//			}
//		}
//		swap(i->word, minNode->word);
//		swap(i->count, minNode->count);
//	}
//}
//
//// WORKED
//// display overall sentiment results
//void LinkedList::displaySentimentResult(int totalReviews, int totalPositive, int totalNegative, WordNode* positiveListHead, WordNode* negativeListHead)
//{
//	cout << "Total Reviews = " << totalReviews << endl;
//	cout << "Total Counts of Positive Words = " << totalPositive << endl;
//	cout << "Total Counts of Negative Words = " << totalNegative << endl;
//
//	/*cout << endl;
//
//	cout << "Positive Words Frequency:" << endl;
//	for (WordNode* node = positiveListHead; node != nullptr; node = node->next)
//	{
//		cout << setw(15) << node->word << " = " << node->count << " times" << endl;
//	}
//
//	cout << endl;
//
//	cout << "Negative Words Frequency:" << endl;
//	for (WordNode* node = negativeListHead; node != nullptr; node = node->next)
//	{
//		cout << setw(15) << node->word << " = " << node->count << " times" << endl;
//	}*/
//
//	// combine +ve and -ve linked list
//	WordNode* combinedListHead = mergeLists(positiveListHead, negativeListHead);
//
//	// sort the combined list 
//	selectionSort(combinedListHead);
//
//	// display result
//	cout << "Frequency of each word used in overall reviews, listed in ascending order based on frequency:" << endl << endl;
//
//	for (WordNode* node = combinedListHead; node != nullptr; node = node->next)
//	{
//		cout << node->word << " = " << node->count << " times " << endl;
//	}
//
//	// clean up the combined list
//	while (combinedListHead != nullptr)
//	{
//		WordNode* temp = combinedListHead;
//		combinedListHead = combinedListHead->next;
//		delete temp;
//	}
//}